Secrets of Admin Routing
========================

by %s on July 14, 2009

During the CakeFest workshop in Berlin, one of the many topics covered
was the routing system. While we touched on most of the general usage
patterns, one of the features we didn't go into depth on was admin
routing. Unsurprisingly, this is the feature we received the most
requests for more information on.
In CakePHP, admin routing is pretty simple: you turn it on, you turn
it off, you change the prefix. But there's not much else you can do
with it. Right?

I'm about to reveal a little secret about this piece of code:

::

    Configure::write('Routing.admin', 'admin');

It's pretty much irrelevant.

Initially (i.e. 1.1 era and prior), admin routing was fairly static.
However, it was refactored in 1.2 such that you could create admin
routes (now called 'prefix routes') the same way you create normal
routes. The configuration itself was maintained for backwards
compatibility, but the following is almost functionally identical:

::

    Router::connect('/admin/:controller/:action/*', array(
    	'action' => null, 'prefix' => 'admin', 'admin' => true
    ));

I say 'almost' because the one thing that this code does not cover is
plugins; but that can be corrected just as simply:

::

    if ($plugins = Configure::listObjects('plugin')) {
    	$pluginMatch = implode('|', array_map(array('Inflector', 'underscore'), $plugins));
    	Router::connect(
    		"/admin/:plugin/:controller/:action/*",
    		array('action' => null, 'prefix' => 'admin', 'admin' => true),
    		array('plugin' => $pluginMatch)
    	);
    }

A quick explanation of the parameters:

+ 'prefix' => 'admin' - this is a special routing key which defines
  the prefix that is appended to the action. Since this key modifies the
  way in which the request is dispatched, rather than the request
  itself, it is not factored into reverse routing. Which brings us to
  the next key...
+ 'admin' => true - because the 'prefix' key is not factored into
  reverse routing, we need a custom flag to differentiate the route, and
  give us something to check when a request hits this route. While the
  name of this key matches the value of 'prefix' by convention, this
  flag can actually be anything, so long as it is not user-modifiable
  (i.e., not present in the URL template itself).
+ 'action' => null - this allows the route to match with or without
  the action being specified (in which case it defaults to the 'index'
  action as normal).
+ 'plugin' => $pluginMatch - in the plugin route, this key is present
  in the third parameter to ensure that the :plugin only matches a valid
  plugin name.

Using these flags, you can create as many prefix routes for as many
purposes as you want. Keep in mind, however, that these flags do not
persist by default. However, you can tell Cake to persist certain
parameters automatically, as in this example with PaginatorHelper:

::

    $paginator->options(array('url' => array('admin' => true)));
    echo $paginator->link('Page 2', array('page' => 2));

However, this only applies to URLs generated by PaginatorHelper. To
generalize this to all helpers, you can implement a simple check in
AppHelper, that works as follows:

::

    App::import('Core', 'Helper');
    
    class AppHelper extends Helper {
    
    	function url($url = null, $full = false) {
    		if (isset($this->params['admin']) && is_array($url) && !isset($url['admin'])) {
    			$url['admin'] = $this->params['admin'];
    		}
    		return parent::url($url, $full);
    	}
    }

This code can then be extrapolated out to persist any parameters in
your application.


Conclusion
~~~~~~~~~~

Using these techniques, custom prefix routing in CakePHP has never
been simpler or more flexible.

.. meta::
    :title: Secrets of Admin Routing
    :description: CakePHP Article related to admin section,Snippets
    :keywords: admin section,Snippets
    :copyright: Copyright 2009 
    :category: snippets

