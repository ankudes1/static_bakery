Auto Add "current_page" to Links
================================

by bravewhale on July 25, 2010

A Helper class for automatically generating links with classes which
are aware of their association to the current URL.

It is sometimes helpful to generate HtmlHelper links which know if
they are "active"/"current" links. NavHelper will append classes to
links depending on their level of association with the current URL.

For instance, a link generated with NavHelper such as:

::

    $nav->link( 'Users' , array( 'controller' => 'users' , 'action' => 'dashboard' );

When viewed on the page "/users/dashboard" will have automatically
added the classes: "current_controller" and "current_action".

::

    <a class="current_controller current_action" href="/users/dashboard">Users</a>

And when viewed from "/users/index", NavHelper only appends
"current_controller" to the HTML element.

It will also append classes based on parameters:

::

    $nav->link( 'Users' , array( 'controller' => 'users' , 'action' => 'usersAction' , 'parameter1' );

When viewed on the page "/users/userAction/parameter1" adds the class
"current_param_1" to the output:

::

    <a class="current_controller current_action current_param_1" href="/users/userAction/parameter1">Users</a>

The way classes are added is pretty straight forward, but for a more
detailed explanation, please read the documentation.

Please note: it calls the HtmlHelper->link() function, so it expects
the same arguments. It will append classes appropriately when the $url
argument is a string, full URL, or an array. If the $url passed is
exactly the browser url, one additional class is appended:
"current_page". I hope others find it useful.


Helper Class:
`````````````

::

    <?php 
    /**
     * NavHelper class file.
     * 
     * Generates appropriate classes for HTML links.
     * 
     * Brave Whale (http://bravewhale.com)
     * 
     * @copyright     GNU License 2010, Brave Whale
     * @link          http://bravewhale.com  Brave Whale
     * @since         CakePHP(tm) v 1.3
     * @license       GNU License (http://creativecommons.org/licenses/GPL/2.0/)
     */
    /**
     * Nav Helper class for automatically generating classes which are aware of their association with the current URL.
     * 
     * Classes added include "current_controller", "current_action", "current_param_(n)" and for an exact URL match "current_page".
     */
    class NavHelper extends AppHelper {
    	/**
    	 * Requires the HtmlHelper to generate links
    	 * 
    	 * @var array
    	 */
    	var $helpers = array( 'Html' );
    	/**
    	 * Stores all links created using NavHelper for developer reference. Intended for use within NavHelper and debugging.
    	 * 
    	 * @var array()
    	 */
    	var $_links = array();
    	/**
    	 * Stores classes added using setNavClasses. These classes are appended to every link generated by NavHelper
    	 * 
    	 * @var array
    	 */
    	var $_addClasses = array();
    	/**
    	 * Internal counter for each link generated by NavHelper.
    	 * 
    	 * @var numeric
    	 */
    	var $countLinks = 0;
    	/**
    	 * Internal reference to the element in $_link currently being operated on.
    	 * 
    	 * @var numeric
    	 */
    	var $currentLinkKey = 0;
    	/**
    	 * Appends an array or string of classes to each link generated by NavHelper.
    	 * 
    	 * @param mixed $className
    	 * @return void
    	 */
    	function setNavClasses( $className ){
    		if( is_string( $className ) ){
    			$this->_addClasses[] = $className;
    		} else {
    			foreach( $className as $class ){
    				$this->_addClasses[] = $class;
    			}
    		}
    	}
    	/**
    	 * Sets the $this->_link[ $linkKey ][ $valueKey ] to $value. If $valueKey is an array it sets $this->_link[ $linkKey ]
    	 * to $valueKey and ignores $value.
    	 * 
    	 * @param mixed $valueKey
    	 * @param string $value [optional]
    	 * @param numeric $linkKey [optional] default $this->currentLinkKey
    	 * @return void
    	 */
    	function setLink( $valueKey , $value = null , $linkKey = null ){
    		if( $linkKey === null ){ $linkKey =& $this->currentLinkKey; }
    		$currentLink =& $this->_links[ $linkKey ];
    		if( is_array( $valueKey ) ){
    			$currentLink = $valueKey;
    		} else {
    			$currentLink[ $valueKey ] = $value;
    		}
    	}
    	/**
    	 * Returns $this->_link[ $linkKey ]. Intended for internal use and debugging.
    	 * 
    	 * @param numeric $linkKey
    	 * @return void
    	 */
    	function getLink( $linkKey ){
    		return $this->_links[ $linkKey ];
    	}
    	/**
    	 * Returns reference $this->_link[ $linkKey ]. Intended for future development: callback functions will be able to
    	 * modify link data before NavHelper->link() quits.
    	 * 
    	 * @param numeric $linkKey
    	 * @return void
    	 */
    	function &getLinkReference( $linkKey ){
    		return $this->_links[ $linkKey ];
    	}
    	/**
    	 * Prepares NavHelper for the creation of a new link. Intended for internal use.
    	 * 
    	 * @param numeric $linkKey [optional]
    	 * @return void
    	 */
    	function prepNewLink( $linkKey = null ){
    		$this->countLinks++;
    		if( $linkKey === null ){
    			$this->currentLinkKey = $this->countLinks - 1;
    		} else {
    			$this->currentLinkKey = $linkKey;
    		}
    	}
    	/**
    	 * Generates links using HtmlHelper, passing all the same values into HtmlHelper->link().
    	 * 
    	 * It is meant to accept $url as
    	 * a string ( "/controller/action/parameters", "action/parameters" for current controller ),
    	 * a url ( "http://domain.com/controller/action/paramters" ),
    	 * and an array (examples below)
    	 * 		array( 'controller' => 'users' , 'action' => 'test' , 'parameter1' ) for "/users/test/parameter1"
    	 * 		array( 'controller' => 'users' , 'parameter1' ) for "/users/index/parameter1" (because default action is set to index)
    	 * 
    	 * One additional $options parameter is the boolean $options['strict'] (default: true), which determines whether or not to continue appending
    	 * parameter classes if preceding parameters are not the expected value. On strict true, a link "/users/index/1/2/3" on the
    	 * "/users/index/1/3/3" page will get the classes "current_controller current_action current_param_1" but not "current_param_3" because the
    	 * expected value of parameter 2 was not present. If strict is false, it would ignore the unexpected parameter and appended "current_param_3".
    	 * Essentially: if strict is true, the class current_param_(n + 1) added only if current_param_(n) is already added.
    	 * 
    	 * Classes added are:
    	 * 		"current_controller" on (Dispatcher->pass[controller] == controller)
    	 * 		"current_action" on ( (Dispatcher->pass[controller] == controller) && (Dispatcher->pass[action] == action) )
    	 * 		"current_param_(n)" on (
    	 * 				(Dispatcher->pass[controller] == controller) && 
    	 * 				(Dispatcher->pass[action] == action) && 
    	 * 				(Dispatcher->pass[params](n) == param(n))
    	 * 			)
    	 * 		"current_page" if all of the above are true and there are no extra parameters in $url or present in the browser URL.
    	 * 
    	 * @param string $title [optional]
    	 * @param mixed $url [optional]
    	 * @param array $options [optional]
    	 * @param boolean $confirmMessage [optional]
    	 * @return HtmlHelper->link()
    	 */
    	function link( $title = null , $url = null , $options = array(), $confirmMessage = false ){
    		$urlDuplicate = $url;
    		$paramsDuplicate = $GLOBALS['Dispatcher']->params['pass'];
    		$countParams = 0;
    		$controller = false;
    		$action = false;
    		$params = true;
    		if( !isset( $options['strict'] ) ){ $options['strict'] = true; }
    		$link = '';
    		$classes = array();
    		if( is_string( $url ) ){
    			$matches = array();
    			if( preg_match( '/^http/' , $url ) ){
    				if(
    					preg_match(
    						'/(^' . addcslashes( FULL_BASE_URL , '/' ) . addcslashes( $GLOBALS['Dispatcher']->base , '/' ) . ')(.{1,})/',
    						$url,
    						$matches
    					) 
    				){
    					if( isset( $matches[2] ) && ( $matches[2] != '/' ) ){
    						$url = $matches[2];
    					} else {
    						$url = '/pages/home';
    					}
    				} else {
    					return $this->Html->link( $title , $urlDuplicate , $options , $confirmMessage );
    				}
    			}
    			$urlArray = explode( '/' , $url );
    			$url = array();
    			$countUrlArray = count( $urlArray );
    			if( $countUrlArray === 1 ){
    				$url['controller'] = $GLOBALS['Dispatcher']->params['controller'];
    				$url['action'] = $urlArray[0];
    			} else {
    				$url['controller'] = $urlArray[1];
    				if( empty( $urlArray[2] ) ){ $urlArray[2] = 'index'; }
    				$url['action'] = $urlArray[2];
    				unset( $urlArray[0] );
    				unset( $urlArray[1] );
    				unset( $urlArray[2] );
    				foreach( $urlArray as $passParam ){
    					$url[] = $passParam;
    				}
    			}
    		}
    		if( is_array( $url ) ){
    			if( isset( $url['controller'] ) ){
    				$link .= '' . $url['controller'];
    				$controller = $url['controller'];
    				unset( $url['controller'] );
    			} else {
    				$controller = $url[0];
    				$link .= '' . $controller;
    				unset( $url[0] );
    			}
    			if( $GLOBALS['Dispatcher']->params['controller'] === $controller ){
    				$classes[] = 'current_controller';
    			}
    			if( $controller != 'pages' ){
    				$dispatcherAction = $GLOBALS['Dispatcher']->params['action'];
    			} else {
    				if( isset( $paramsDuplicate[0] ) ){
    					$dispatcherAction = $paramsDuplicate[0];
    					unset($paramsDuplicate[0]);
    				} else {
    					$dispatcherAction = 'pages';
    				}
    			}
    			if( isset( $url['action'] ) ){
    				$link .= '/' . $url['action'];
    				$action = $url['action'];
    				unset( $url['action'] );
    			} else {
    				$action = 'index';
    				$link .= '/' . $action;
    			}
    			if( ( $dispatcherAction === $action ) && ( $controller ) ){
    				$classes[] = 'current_action';
    			}
    			foreach( $url as $param ){
    				if(
    					( isset($paramsDuplicate[ $countParams ]) ) &&
    					( $paramsDuplicate[ $countParams ] === $param ) &&
    					( $action )
    				){
    					if( !$options['strict'] || $params ){
    						$classes[] = 'current_param_' . ($countParams+1);
    						$params = true;
    					}
    				} else {
    					$params = false;
    				}
    				$link .= '/' . $param;
    				$countParams++;
    			}
    			unset( $options['strict'] );
    			$expected_here = $GLOBALS['Dispatcher']->base . '/' . $link;
    			$url_path = '/' . $link;
    			if( $expected_here === $GLOBALS['Dispatcher']->here ){
    				$classes[] = 'current_page';
    			}
    			$classesString = implode( ' ' , $classes );
    			if( isset( $options['class'] ) ){
    				$options['class'] .= ' ' . $classesString;
    			} else {
    				$options['class'] = $classesString;
    			}
    		}
    		$options['class'] .= ' ' . implode( ' ' , $this->_addClasses );
    		$this->prepNewLink();
    		$_link = array(
    			'title' => $title,
    			'url' => $link,
    			'url_path' => $url_path,
    			'expected_here' => $expected_here,
    			'classes' => $classes
    		);
    		$this->setLink( $_link );
    		return $this->Html->link( $title , $urlDuplicate , $options , $confirmMessage );
    	}
    }
    ?>



.. author:: bravewhale
.. categories:: articles, helpers
.. tags:: ,Helpers

